<!--
  Copyright 2019, Bart Butenaers, Stephen McLaughlin
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<style>
    .ui-autocomplete {
        max-height: 100px;
        overflow-y: auto;
        overflow-x: hidden; /* prevent horizontal scrollbar */
        /*padding-right: 20px;/* add padding to account for vertical scrollbar */
    } 
</style>

<script type="text/javascript">

    function updateSvgIdHelpers(svgStr) {
        console.log("updateSvgIdHelpers");


        var nonAnimationClasses = [];
        var animationClasses = [];

        var animationIds = [];
        var animationIdSelectors = [];
        
        var nonAnimationIds = [];
        var nonAnimationIdSelectors = [];
        var nonAnimationIdsAndActions = [];
        var animationIdsAndActions = [];
        var svgElement = $(svgStr)[0];

        svgElement.querySelectorAll('[class]').forEach(function (node) {
            node.classList.forEach(function (className) {
                if(!className) return;
                var _class = "." + className;
                var ele = node.tagName;
                ele = ele.trim().toLowerCase();
                if (ele == "set" || ele == "animate" || ele == "animatemotion" || ele == "animatecolor" || ele == "animatetransform") {
                    if (animationClasses.indexOf(_class) < 0) {
                        animationClasses.push(_class)
                    }
                } else {
                    if (nonAnimationClasses.indexOf(_class) < 0) {
                        nonAnimationClasses.push(_class)
                    }
                }
            })
        })

        svgElement.querySelectorAll('*[id]').forEach(function (node) {

            if(!node.id) return;
            
            var id = node.id;
            var ele = node.tagName;
            ele = ele.trim().toLowerCase();

            if(ele == "style") return;

            if (ele == "set" || ele == "animate" || ele == "animatemotion" || ele == "animatecolor" || ele == "animatetransform") {
                if (animationIds.indexOf(id) < 0) {
                    animationIds.push(id)
                    animationIdSelectors.push("#"+id)
                    animationIdsAndActions.push(id)
                    animationIdsAndActions.push(id + ".begin");
                    animationIdsAndActions.push(id + ".end");
                    animationIdsAndActions.push(id + ".repeat(1)");
                }
            } else if(ele != "style" ) {
                if (nonAnimationIds.indexOf(id) < 0) {
                    nonAnimationIds.push(id);
                    nonAnimationIdSelectors.push("#"+id)
                    nonAnimationIdsAndActions.push(id + ".click");
                    nonAnimationIdsAndActions.push(id + ".dblclick");
                    nonAnimationIdsAndActions.push(id + ".contextmenu");
                    nonAnimationIdsAndActions.push(id + ".mouseover");
                    nonAnimationIdsAndActions.push(id + ".mouseout");
                    nonAnimationIdsAndActions.push(id + ".mouseup");
                    nonAnimationIdsAndActions.push(id + ".mousedown");
                    nonAnimationIdsAndActions.push(id + ".focus");
                    nonAnimationIdsAndActions.push(id + ".focusin");
                    nonAnimationIdsAndActions.push(id + ".focusout");
                    nonAnimationIdsAndActions.push(id + ".blur");
                    nonAnimationIdsAndActions.push(id + ".keyup");
                    nonAnimationIdsAndActions.push(id + ".keydown");
                    nonAnimationIdsAndActions.push(id + ".touchstart");
                    nonAnimationIdsAndActions.push(id + ".touchend");
                }
            }
        })

        //Get all animation ids specified by the SMIL animations editable list...
        var smilAnimationsList = $("#node-input-animations-container").editableList('items');
        smilAnimationsList.each(function(i) {
            var aid = $(this).find(".node-input-animation-id").val();    
            if(!aid) return;            
            if (animationIds.indexOf(aid) < 0) {
                animationIds.push(aid);
                animationIdsAndActions.push(aid + ".begin");
                animationIdsAndActions.push(aid + ".end");
                animationIdsAndActions.push(aid + ".repeat(1)");
            }
        });

        
        $(".node-input-animation-targetId").autocomplete({
            source: nonAnimationIds
        });
        $(".node-input-clickable-targetId").autocomplete({
            source: [...nonAnimationIdSelectors,...nonAnimationClasses]
        });
        $(".node-input-animation-attributeName").autocomplete({
            source: [
                        'clipPathUnits',
                        'cx',
                        'cy',
                        'd',
                        'display',
                        'dx',
                        'dy',
                        'fill',
                        'fx',
                        'fy',
                        'gradientTransform',
                        'gradientUnits',
                        'height',
                        'lengthAdjust',
                        'markerHeight',
                        'markerUnits',
                        'markerWidth',
                        'maskContentUnits',
                        'maskUnits',
                        'method',
                        'offset',
                        'orient',
                        'pathLength',
                        'patternContentUnits',
                        'patternTransform',
                        'patternUnits',
                        'points',
                        'preserveAspectRatio',
                        'r',
                        'refX',
                        'refY',
                        'rotate',
                        'rx',
                        'ry',
                        'spacing',
                        'spreadMethod',
                        'startOffset',
                        'textLength',
                        'transform',
                        'viewBox',
                        "visibility",
                        'width',
                        'x',
                        'x1',
                        'x2',
                        'y',
                        'y1',
                        'y2',
                        ]

        });

        function tagSplit(val) {
            return val.split(/;\s*/);
        }
        function extractLastTag(term) {
            return tagSplit(term).pop();
        }
        
        $(".node-input-animation-custom")
            .on("keydown", function (event) {
                
                if($(this).autocomplete("instance").menu.active){
                    var appendChar = "; ";
                    var takeInput = true;
                    switch (event.keyCode) {
                        case $.ui.keyCode.RIGHT:
                        appendChar = "";
                        break;
                        case 186:
                        appendChar = "; ";
                        break;
                        case $.ui.keyCode.PERIOD:
                        appendChar = ".";
                        break;
                        default:
                        takeInput = false;
                    }
                    
                    if (event.keyCode === $.ui.keyCode.TAB) {
                        event.preventDefault();// don't navigate away from the field on tab when selecting an item
                    } else if (takeInput) {
                        let terms =  tagSplit(this.value);
                        let selected = $(this).autocomplete("instance").menu.active.text()
                        terms.pop();// remove the current input 
                        terms.push(selected + appendChar); // add the selected item
                        this.value = terms.join("; ");
                        event.preventDefault();// don't navigate away from the field
                    }
                }
            })
            .on("click", function (event) {
                //show dropdown on click (disabled/annoying/problematic)
                //$( this ).autocomplete( "search", "" )
            })
            .autocomplete({
                minLength: 0,
                source: function (request, response) {
                    //TODO: Consider how to handle editing in middle of string
                    //currently, the last tag (after last ;) is used.
                    let list;
                    let lastTag = extractLastTag(request.term);
                    if(lastTag.includes(".")){
                        list = [...nonAnimationIdsAndActions,...animationIdsAndActions]; 
                    } else {
                        list = [...nonAnimationIds, ...animationIds]; 
                    }
                    // delegate back to autocomplete, but extract the last term
                    response($.ui.autocomplete.filter(list, lastTag));
                },
                focus: function () {
                    // prevent value inserted on focus
                    return false;
                },
                select: function (event, ui) {
                    var terms = tagSplit(this.value);

                    terms.pop();// remove the current input 
                    terms.push(ui.item.value); // add the selected item
                    // add placeholder to get the comma-and-space at the end
                    terms.push("");
                    this.value = terms.join("; ");
                    return false;
                }
            });

    }

    // function updateSvgIdHelpers(svg) {
    //     console.log("updateSvgIdHelpers");
    //     //var regex = /<.*?(\S+).+?id="(.+?)"/gm; //SM - NG
    //     //var regex = /<[^\s]+.*?id *= *"([^"]*?)".*?>/g;//BB - NG
    //     var regex = /<\W*?(\w+)[^>]*?id\s*?=\s*?"([^"]*?)".*?>/gms;//Works with new line & whitespace after < 
    //     var str = svg//$("#fullthing").html();
    //     var match;
    //     var elementsIdsOnly = [];
    //     var elementIdsAndActions = [];
    //     var animationElements = [];
    //     var nonAnimationElements = [];
        
    //     while ((match = regex.exec(str)) !== null) {
    //         // This is necessary to avoid infinite loops with zero-width matches
    //         if (match.index === regex.lastIndex) {
    //             regex.lastIndex++;
    //         }

    //         if (match.length > 2) {
    //             let full = match[0];
    //             let ele = match[1] || "";
    //             let id = match[2] || "";
    //             ele = ele.trim().toLowerCase();
    //             elementsIdsOnly.push(match[2]);
    //             if (ele == "set" || ele == "animate" || ele == "animatemotion" || ele == "animatecolor" || ele == "animatetransform") {
    //                 animationElements.push(match[2]);
    //                 elementIdsAndActions.push(match[2] + ".begin");
    //                 elementIdsAndActions.push(match[2] + ".end");
    //                 elementIdsAndActions.push(match[2] + ".repeat(1)");
    //             } else {
    //                 nonAnimationElements.push(match[2]);
    //                 elementIdsAndActions.push(match[2] + ".click");
    //                 elementIdsAndActions.push(match[2] + ".dblclick");
    //                 elementIdsAndActions.push(match[2] + ".contextmenu");
    //                 elementIdsAndActions.push(match[2] + ".mouseover");
    //                 elementIdsAndActions.push(match[2] + ".mouseout");
    //                 elementIdsAndActions.push(match[2] + ".mouseup");
    //                 elementIdsAndActions.push(match[2] + ".mousedown");
    //                 elementIdsAndActions.push(match[2] + ".focus");
    //                 elementIdsAndActions.push(match[2] + ".focusin");
    //                 elementIdsAndActions.push(match[2] + ".focusout");
    //                 elementIdsAndActions.push(match[2] + ".blur");
    //                 elementIdsAndActions.push(match[2] + ".keyup");
    //                 elementIdsAndActions.push(match[2] + ".keydown");
    //                 elementIdsAndActions.push(match[2] + ".touchstart");
    //                 elementIdsAndActions.push(match[2] + ".touchend");
    //             }
    //         }
    //     }

    //     //Get all animation ids specified by the SMIL animations editable list...
    //     var smilAnimationsList = $("#node-input-animations-container").editableList('items');
    //     smilAnimationsList.each(function(i) {
    //         var id = $(this).find(".node-input-animation-id").val();                
    //         animationElements.push(id);
    //     });

    //     $(".node-input-animation-targetId").autocomplete({
    //         source: nonAnimationElements
    //     });
    //     $(".node-input-clickable-targetId").autocomplete({
    //         source: nonAnimationElements
    //     });

    //     function tagSplit(val) {
    //         return val.split(/;\s*/);
    //     }
    //     function extractLastTag(term) {
    //         return tagSplit(term).pop();
    //     }

    //     $(".node-input-animation-custom")
    //         .on("keydown", function (event) {
                
    //             if($(this).autocomplete("instance").menu.active){
    //                 var appendChar = "; ";
    //                 var takeInput = true;
    //                 switch (event.keyCode) {
    //                     case $.ui.keyCode.RIGHT:
    //                     appendChar = "";
    //                     break;
    //                     case 186:
    //                     appendChar = "; ";
    //                     break;
    //                     case $.ui.keyCode.PERIOD:
    //                     appendChar = ".";
    //                     break;
    //                     default:
    //                     takeInput = false;
    //                 }
                    
    //                 if (event.keyCode === $.ui.keyCode.TAB) {
    //                     event.preventDefault();// don't navigate away from the field on tab when selecting an item
    //                 } else if (takeInput) {
    //                     let terms =  tagSplit(this.value);
    //                     let selected = $(this).autocomplete("instance").menu.active.text()
    //                     terms.pop();// remove the current input 
    //                     terms.push(selected + appendChar); // add the selected item
    //                     this.value = terms.join("; ");
    //                     event.preventDefault();// don't navigate away from the field
    //                 }
    //             }
    //         })
    //         .on("click", function (event) {
    //             //show dropdown on click (disabled/annoying/problematic)
    //             //$( this ).autocomplete( "search", "" )
    //         })
    //         .autocomplete({
    //             minLength: 0,
    //             source: function (request, response) {
    //                 //TODO: Consider how to handle editing in middle of string
    //                 //currently, the last tag (after last ;) is used.
    //                 let list;
    //                 let lastTag = extractLastTag(request.term);
    //                 if(lastTag.includes(".")){
    //                     list = elementIdsAndActions; 
    //                 } else {
    //                     list = elementsIdsOnly; 
    //                 }
    //                 // delegate back to autocomplete, but extract the last term
    //                 response($.ui.autocomplete.filter(list, lastTag));
    //             },
    //             focus: function () {
    //                 // prevent value inserted on focus
    //                 return false;
    //             },
    //             select: function (event, ui) {
    //                 var terms = tagSplit(this.value);

    //                 terms.pop();// remove the current input 
    //                 terms.push(ui.item.value); // add the selected item
    //                 // add placeholder to get the comma-and-space at the end
    //                 terms.push("");
    //                 this.value = terms.join("; ");
    //                 return false;
    //             }
    //         });


    // }


    function updateEditorHeight(node, editor) {
        console.log("updateEditorHeight");
        //resize the tab content divs to available height
        var formRows = $("#dialog-form>div:not(#node-svg-tabs-content)");
        var height = $("#dialog-form").height() - 5;
        for (let i=0; i < formRows.length; i++) {
            height -= $(formRows[i]).outerHeight(true);
        }
        //if ($('#node-input-templateScope').val() === "global") { h += 232; }
        $("#node-svg-tabs-content").css("height",height+"px");//set size of tabs area
        //now resize the item with class form-row-auto-height
        var tabs = $('.node-svg-tab-content');
        for (let index = 0; index < tabs.length; index++) {
            let tab = $(tabs[index]);
            tab.css("height",height+"px");
            let expandRow = $(tab.find('.form-row-auto-height'));
            if(expandRow && expandRow.length){
                let tabHeight = height;
                let childRows = tab.find('.form-row:not(.form-row-auto-height)');
                for (let i=0; i<childRows.size(); i++) {
                    tabHeight -= $(childRows[i]).outerHeight(true);
                }
                let ol = $(expandRow.find(".red-ui-editableList-list"));
                if(ol && ol.length){
                    ol.editableList("height",tabHeight);
                } else {
                    expandRow.css("height",tabHeight+"px");
                }
            } 
        }
        if ( editor ) {
            // Is the editor is in full-screen? ...
            node.fullscreen = document.fullscreenElement ? true : false;
            var rows = $("#node-svg-tab-editor>div:not(.node-text-editor-row)");
            var height = $("#node-svg-tab-editor").height() - 25;
            for (var i=0; i<rows.size(); i++) {
                height = height - $(rows[i]).outerHeight(true);
            }
            if ($('#node-input-templateScope').val() === "global") { height += 232; }
           
            if (node.fullscreen) {
                $('#node-expand-svg-editor').html('<i class="fa fa-compress"></i>')//compress icon
            } else {               
                $('#node-expand-svg-editor').html('<i class="fa fa-expand"></i>')//expand icon
            }
            
            // Set the height of the edit box
            $('#node-input-svg-editor').css('height',height+'px');
            // Get the content to match the edit box size
            if(editor) editor.resize();
        }
        $(".node-input-clickable-payload").typedInput('width');//layout workaround until NR V1 https://discourse.nodered.org/t/toggle-visibility-of-typedinput-field-layout-issue/12756/11

    } 

    function getAnimationObjectFromFormRow(ele){
        var row = $(ele);
        var id            = row.find(".node-input-animation-id").val();
        var targetId      = row.find(".node-input-animation-targetId").val();
        var attributeName = row.find(".node-input-animation-attributeName").val();
        var fromValue     = row.find(".node-input-animation-fromValue").val();
        var toValue       = row.find(".node-input-animation-toValue").val();
        var trigger       = row.find(".node-input-animation-trigger").val();
        var duration      = row.find(".node-input-animation-duration").val();
        var durationUnit  = row.find(".node-input-animation-durationUnit").val();
        var repeatCount   = row.find(".node-input-animation-repeatCount").val();
        var freeze        = row.find(".node-input-animation-freeze").is(":checked");
        var delay         = row.find(".node-input-animation-delay").val();
        var delayUnit     = row.find(".node-input-animation-delayUnit").val();
        var otherId       = row.find(".node-input-animation-otherId").val();
        var custom        = row.find(".node-input-animation-custom").val();        
        return {id:id, targetId:targetId, attributeName:attributeName, fromValue:fromValue, toValue:toValue, trigger:trigger, duration:duration, durationUnit:durationUnit, repeatCount:repeatCount, freeze:freeze, delay:delay, otherId:otherId, delayUnit:delayUnit, custom:custom};
    }

    RED.nodes.registerType('ui_svg_graphics',{
        category: 'dashboard',
        color: 'rgb( 63, 173, 181)',
        defaults: {
            group: {type: 'ui_group', required:true},
            order: {value: 0},
            width: {
                value: 0,
                validate: function(v) {
                    var valid = true
                    var width = v||0;
                    var currentGroup = $('#node-input-group').val()|| this.group;
                    var groupNode = RED.nodes.node(currentGroup);
                    valid = !groupNode || +width <= +groupNode.width;
                    $("#node-input-size").toggleClass("input-error",!valid);
                    return valid;
                }},
            height: {value: 0},
            svgString: {value: '<svg height="100" width="100"></svg>'},
            clickableShapes: {value: []},
            smilAnimations: {value: []},
            showCoordinates: {value: false},
            outputField: {value: "payload"},
            //showMouseLines: {value: false},
            name: {value: ''}
        },
        inputs:1,
        outputs:1,
        icon: "svg.png",
        align: 'left',
        paletteLabel:"SVG graphics",
        label: function() {
            return this.name || "SVG graphics";
        },
        oneditprepare: function() {
            var node = this;
            node.initialised = true;
            $("#node-input-size").elementSizer({
                width: "#node-input-width",
                height: "#node-input-height",
                group: "#node-input-group"
            });
            if (typeof this.templateScope === 'undefined') {
                this.templateScope = 'local';
                $('#node-input-templateScope').val(this.templateScope);
            }
            $('#node-input-templateScope').on('change', function() {
                if ($('#node-input-templateScope').val() === 'global') {
                    $('#template-row-group, #template-row-size, #template-pass-store').hide();
                    node._def.defaults.group.required = false;
                }
                else {
                    $('#template-row-group, #template-row-size, #template-pass-store').show();
                    node._def.defaults.group.required = true;
                }
                var rows = $("#dialog-form>div:not(.node-text-editor-row)");
                var height = $("#dialog-form").height();
                for (var i=0; i<rows.size(); i++) {
                    height = height - $(rows[i]).outerHeight(true);
                }
                if ($('#node-input-templateScope').val() === "global") { height += 240; }
                var editorRow = $("#dialog-form>div.node-text-editor-row");
                height -= (parseInt(editorRow.css("marginTop")) + parseInt(editorRow.css("marginBottom")));
                $(".node-text-editor").css("height",height+"px");
                if (this.editor) { this.editor.resize(); }
            })
            
            // Show tabsheets
            var tabs = RED.tabs.create({
                id: "node-svg-tabs",
                onchange: function(tab) {
                    //console.log("tabs.onchange",tab);
                    // Show only the content (i.e. the children) of the selected tabsheet, and hide the others
                    $("#node-svg-tabs-content").children().hide();
                    $("#" + tab.id).show();
                    updateEditorHeight(node,node.editor);
                    if(tab.id == "node-svg-tab-animations" || tab.id == "node-svg-tab-clickable"){
                        let svgStr = node.editor ? node.editor.getValue() : ""; 
                        try {
                            updateSvgIdHelpers(svgStr);    
                        } catch (error) {
                            console.error(error)
                        }
                    }
                }
            });
            tabs.addTab({
                id: "node-svg-tab-editor",
                label: "SVG editor"
            });
            tabs.addTab({
                id: "node-svg-tab-animations",
                label: "Animations"
            });
            tabs.addTab({
                id: "node-svg-tab-clickable",
                label: "Events"
            });
            tabs.addTab({
                id: "node-svg-tab-settings",
                label: "Settings"
            });              
            this.fullscreen = false;
            this.editor = RED.editor.createEditor({
                id: 'node-input-svg-editor',
                mode: 'ace/mode/html',
                value: $("#node-input-svgString").val()
            });
            RED.library.create({
                url:"uitemplates", // where to get the data from
                type:"ui_template", // the type of object the library is for
                editor:this.editor, // the field name the main text body goes to
                mode:"ace/mode/svg",
                fields:['name']
            });
            this.editor.focus();
            var fullScrElement = $('#node-svg-tab-editor')[0];
            var fsr = fullScrElement.requestFullscreen || fullScrElement.mozRequestFullScreen || fullScrElement.webkitRequestFullscreen || fullScrElement.msRequestFullScreen;
            if(fsr){
                $('#node-expand-svg-editor').click(function(e) {
                    e.preventDefault()
                    if (node.fullscreen === false) {
                        if (fsr) {
                            fsr.call(fullScrElement);//triggers oneditresize()
                        }
                    } else {
                        document.exitFullscreen();//triggers oneditresize()
                    }
                })
            } else {
                $('#node-expand-svg-editor').hide();
            }
            
            function addPropertyRow(container, propertyName) {
                var propertyRow = $('<div/>',{style:"margin-top:8px;"}).appendTo(container);
                $('<div/>', {style:"display:inline-block;text-align:right; width:120px; padding-right:10px; box-sizing:border-box;"})
                .text(propertyName)
                .appendTo(propertyRow);
                
                return propertyRow;
            }
            
            function getTitle(animation) {
                if (animation && animation.id != "") {
                    return "Animation ( " + animation.id + " : '" + animation.targetId + "' : '" + animation.attributeName + "' )";
                }
                else {
                    return "Animation ( unknown id )";
                }
            }
            
            // Create a table of (SMIL) animations
            // Columns: element id - attributeName - from - to - duration - repeatCount - freeze
            var smilAnimationsList = $("#node-input-animations-container").css('min-height','150px').css('min-width','400px').editableList({
                addItem: function(container, i, animation) {
                    // By default the list items will be compressed, so show the expand icon
                    var expandIcon = "fa fa-angle-right";
                    
                    // When animation === {} then we have a new list item (i.e. user pressed the addItem button)
                    if (Object.keys(animation).length === 0) {
                        // Initialize new items in the list.
                        animation = {
                            id            : "", 
                            targetId      : "",
                            attributeName : "",
                            fromValue     : "",
                            duration      : 1,
                            durationUnit   : "s",
                            repeatCount   : 0,
                            freeze        : false,
                            trigger       : "msg",
                            delay         : 1,
                            delayUnit     : "s",
                            otherId       : "",
                            custom        : ""
                        };
                        
                        // New list items should be expanded by default, so show a compress icon.
                        // This way the user becomes aware which properties the new widget offers...
                        expandIcon = "fa fa-angle-down";
                    }
                    
                    if(animation.expand){
                        delete animation.expand
                        expandIcon = "fa fa-angle-down";
                    }

                    container.css({
                        overflow: 'hidden',
                        whiteSpace: 'nowrap'
                    });
                    
                    var headerRow = $('<div/>').appendTo(container);
                    
                    // Show a click-able expand/compress icon before each header row.
                    var expandButton = $('<span/>', {style: "margin-left:5px; margin-right:10px;"}).html('<i class="' + expandIcon + '"></i>').appendTo(headerRow);
                    
                    // The header line title depends on the animation id
                    var title = getTitle(animation);
                    
                    var titleField = $('<span/>', {style: "margin-left:10px; margin-right:10px; font-weight:Bold"}).text(title).appendTo(headerRow);
                    titleField.click(function(evt){
                        expandButton.trigger( "click" )
                    })
                    // The COMMON ROWS contain the common animation properties:
                    // - Animation id
                    // - Target id
                    // - Attribute name
                    // - From value
                    // - To value
                    // - Duration + DurationUnit
                    // - Repeat count
                    // - Freeze
                    // - Trigger type
                    
                    // Add an 'animation id' property row
                    var animationIdRow = addPropertyRow(container, "Animation id");
                    var animationIdField = $('<input/>', {class: "node-input-animation-id", style: "width:160px; margin-right:10px;", type: "text"}).appendTo(animationIdRow);
                    animationIdField.val(animation.id);
                    $('<span/>').text('%').appendTo(animationIdField);
        

                    function updateTitle(ele){
                        var par = $(ele).parent().parent();
                        var anim = getAnimationObjectFromFormRow(par);
                        var newTitle = getTitle(anim);
                        titleField.text(newTitle);
                    }

                    // Add a 'target id' property row
                    var targetIdRow = addPropertyRow(container, "Target Element Id");
                    var targetIdField = $('<input/>', {class: "node-input-animation-targetId", style: "width:160px; margin-right:10px;", type: "text"}).appendTo(targetIdRow);
                    targetIdField.val(animation.targetId);
                    $('<span/>').text('%').appendTo(targetIdField);

                    // Add an 'attribute name' property row
                    var attributeNameRow = addPropertyRow(container, "Attribute name");
                    var attributeNameField = $('<input/>', {class: "node-input-animation-attributeName", style: "width:160px; margin-right:10px;", type: "text"}).appendTo(attributeNameRow);
                    attributeNameField.val(animation.attributeName);
                    $('<span/>').text('%').appendTo(attributeNameField);

                    // When the animation id changes, the header line title should also be changed
                    animationIdField.on("change", function(){
                        updateTitle(this)
                    });
                    targetIdField.on("change", function(){
                        updateTitle(this)
                    });
                    attributeNameField.on("change", function(){
                        updateTitle(this)
                    });


                    // Add a 'from value' property row
                    var fromValueRow = addPropertyRow(container, "From value");
                    var fromValueField = $('<input/>', {class: "node-input-animation-fromValue", style: "width:160px; margin-right:10px;", type: "text"}).appendTo(fromValueRow);
                    fromValueField.val(animation.fromValue);
                    $('<span/>').text('%').appendTo(fromValueField);

                    // Add a 'to value' property row
                    var toValueRow = addPropertyRow(container, "To value");
                    var toValueField = $('<input/>', {class: "node-input-animation-toValue", style: "width:160px; margin-right:10px;", type: "text"}).appendTo(toValueRow);
                    toValueField.val(animation.toValue);
                    $('<span/>').text('%').appendTo(toValueField);

                    // Add a 'duration' property row
                    var durationRow = addPropertyRow(container, "Duration");
                    var durationField = $('<input/>', {class: "node-input-animation-duration", style: "width:160px; margin-right:10px;", type: "number"}).appendTo(durationRow);
                    durationField.val(animation.duration);
                    $('<span/>').text('%').appendTo(durationField);
                    var delayUnitField = $('<select/>', {class: "node-input-animation-durationUnit", style: "width:120px; margin-right:10px;", type: "text"}).appendTo(durationRow);
                    delayUnitField.append($('<option>', {value: "ms", text: 'milliseconds'}));
                    delayUnitField.append($('<option>', {value: "s", text: 'seconds'}));
                    delayUnitField.append($('<option>', {value: "min", text: 'minutes'}));
                    delayUnitField.val(animation.durationUnit || "s");
                    
                    // Add a 'repeat count' property row
                    var repeatCountRow = addPropertyRow(container, "Repeat count");
                    var repeatCountField = $('<input/>', {class: "node-input-animation-repeatCount", style: "width:160px; margin-right:10px;", type: "number"}).appendTo(repeatCountRow);
                    repeatCountField.val(animation.repeatCount);
                    $('<span/>').text('%').appendTo(repeatCountField);                    

                    // Add a 'freeze' property row
                    var freezeRow = addPropertyRow(container, "Freeze");
                    var freezeField = $('<input/>', {class: "node-input-animation-freeze", style: "width:160px; margin-right:10px;", type: "checkbox"}).appendTo(freezeRow);
                    freezeField.prop('checked', animation.freeze);
                    $('<span/>').text('%').appendTo(freezeField);   
                    
                    // Add a 'trigger' property row
                    var triggerRow = addPropertyRow(container, "Trigger");
                    var triggerField = $('<select/>',{class:"node-input-animation-trigger", style:"width:160px; margin-right:10px;"}).appendTo(triggerRow);
                    triggerField.append($("<option></option>").val('msg').text("Input message"));
                    triggerField.append($("<option></option>").val('time').text("Time delay"));
                    //triggerField.append($("<option></option>").val('anim').text("Other animation"));
                    triggerField.append($("<option></option>").val('cust').text("Custom"));
                    triggerField.val(animation.trigger);
    
                    expandButton.click(function(e) {
                        e.preventDefault();
                        
                        // Switch the icon between expand and compress
                        if (this.firstElementChild.className === "fa fa-angle-right") {
                            this.firstElementChild.className = "fa fa-angle-down";
                        }
                        else {
                            this.firstElementChild.className = "fa fa-angle-right";
                        }
                    
                        // Only show the relevant widget type properties
                        triggerField.change();
                    });
                    
                    // The (common) row ends here ...
                    // The OTHER rows will only be visible depending on the animation trigger type:
                    // - Delay
                    // - Other id
                    // - Custom
            
                    // Add a 'delay' property row
                    var delayRow = addPropertyRow(container, "Delay");
                    var delayField = $('<input/>', {class: "node-input-animation-delay", style: "width:160px; margin-right:10px;", type: "number"}).appendTo(delayRow);
                    delayField.val(animation.delay);
                    $('<span/>').text('%').appendTo(delayField);
                    var delayUnitField = $('<select/>', {class: "node-input-animation-delayUnit", style: "width:120px; margin-right:10px;", type: "text"}).appendTo(delayRow);
                    delayUnitField.append($('<option>', {value: "ms", text: 'milliseconds'}));
                    delayUnitField.append($('<option>', {value: "s", text: 'seconds'}));
                    delayUnitField.append($('<option>', {value: "min", text: 'minutes'}));
                    delayUnitField.val(animation.delayUnit || "s");
                    
                    // // Add an 'other animation id' property row
                    // var otherIdRow = addPropertyRow(container, "Other animation id");
                    // var otherIdField = $('<input/>', {class: "node-input-animation-otherId", style: "width:160px; margin-right:10px;", type: "text"}).appendTo(otherIdRow);
                    // otherIdField.val(animation.otherId);
                    // $('<span/>').text('%').appendTo(otherIdField);
                    
                    // Add a 'custom' property row
                    var customRow = addPropertyRow(container, "Custom");
                    var customField = $('<input/>', {class: "node-input-animation-custom", style: "width:70%; margin-right:10px;", type: "text"}).appendTo(customRow);
                    customField.val(animation.custom);
                    $('<span/>').text('%').appendTo(customField);
                    customRow.append($("<i />", {class:"fa fa-question", title:"Press down to select, right to accept, dot to access properties, semicolon/enter/tab to complete the entry."}));

                    //add duplicate button
                    var duplicateButton = $('<a/>', {class: "red-ui-editableList-item-remove red-ui-button red-ui-button-small", style: "margin-right: 28px"}).appendTo(container);
                    duplicateButton.html('<i class="fa fa-clone"></i>')
                    var anim = animation;
                    var animList = smilAnimationsList;
                    duplicateButton.click(function(evt){
                        debugger
                        var anew = $.extend({}, animation);//shallow clone
                        anew.id += "_copy";
                        anew.expand = true;
                        animList.editableList('addItem', anew);
                    })
                    
                    // When the trigger type changes, only the relevant property rows should be visible
                    triggerField.change(function() {
                        var triggerType = $(this).val();
                        
                        animationIdRow.hide();
                        targetIdRow.hide();
                        attributeNameRow.hide();
                        fromValueRow.hide();
                        toValueRow.hide();
                        durationRow.hide();
                        repeatCountRow.hide();
                        freezeRow.hide();
                        triggerRow.hide();
                        delayRow.hide();
                        //otherIdRow.hide();
                        customRow.hide();
                        
                        // When the button shows a 'compress' icon, this means that the list item is currently expanded
                        // (i.e. that all relevant property rows should be visible)
                        if (expandButton.children()[0].className === "fa fa-angle-down") {
                            // The (common) header rows should be visible for all widget types
                            animationIdRow.show();
                            targetIdRow.show();
                            attributeNameRow.show();
                            fromValueRow.show();
                            toValueRow.show();
                            durationRow.show();
                            repeatCountRow.show();
                            freezeRow.show();
                            triggerRow.show();
                        
                            // Some other property rows should only be visible for specific trigger types
                            switch (triggerType) {
                                case 'msg':
                                    // No extra property rows to show
                                    break;
                                case 'time':
                                    delayRow.show();                                   
                                    break;
                                case 'anim':
                                    //otherIdRow.show();
                                    break;
                                case 'cust':
                                    customRow.show();
                                    break;
                            }
                        }
                    });
                    
                    // Only show the relevant widget type properties
                    triggerField.change();
                    if(node.initialised){
                        let svgStr = node.editor ? node.editor.getValue() : ""; 
                        try {
                            updateSvgIdHelpers(svgStr);    
                        } catch (error) {
                            console.error(error)
                        }
                    }
                },                    
                removable: true,
                sortable: false
            });
            
            // Show all the animations (stored in this node) into the editableList
            if (this.smilAnimations) {
                this.smilAnimations.forEach(function (smilAnimation, index) {
                    smilAnimationsList.editableList('addItem', smilAnimation);
                });
            }
            // Create a table of clickable shapes
            const supportedPayloadTypes = ['flow', 'global', 'str', 'num', 'bool', 'json', 'date'];
            const defaultPayloadType = "str";
            var clickableShapesList = $("#node-input-clickable-container").css('min-height','150px').css('min-width','450px').editableList({
                header: $("<div>").append($.parseHTML("<div style='width:17%; margin-left:5px; display: inline-grid'><b>Selector</b></div><div style='width:20%; margin-left:5px; display: inline-grid'><b>Action</b></div><div style='width:38%; margin-left:4px; display: inline-grid'><b>Payload</b></div><div style='width:17%; margin-left:-3px; display: inline-grid'><b>Topic</b></div>")),
                addItem: function(container, i, clickableShape) {
                    // Add a new row to the editableList
                    var row = $('<div/>').appendTo(container);
                    
                    // Column 1 : Add an input field (type string) to the new row, that represents the SVG element ID 
                    var targetIdField = $('<input/>',{class:"node-input-clickable-targetId",type:"text",placeholder:"SVG element Selector"}).css({"width":"17%","margin-left":"5px","margin-right":"5px"}).appendTo(row);
                    targetIdField.val(clickableShape.targetId);
                    
                    // Column 2 : Add an input field (type option) to the new row, that represents the action type 
                    var actionField = $('<select/>',{class:"node-input-clickable-action",type:"text",placeholder:"click"}).css({"width":"20%","margin-left":"5px","margin-right":"5px"}).appendTo(row);
                    var actionOptions = {
                        //https://www.w3.org/TR/2015/WD-SVG2-20150407/interact.html#SVGEvents
                        'click':'click',//A click is defined as a mousedown and mouseup over the same screen location. Works on tablet too.
                        'dblclick':'dblclick',
                        'contextmenu':'contextmenu',
                        'mousedown':'mousedown',//Occurs when the pointing device button is pressed over an element.
                        'mouseup':'mouseup',//Occurs when the pointing device button is released over an element.
                        'mouseover':'mouseover',//Occurs when the pointing device is moved onto an element.
                        'mouseout':'mouseout', //Occurs when the pointing device is moved away from an element
                        //'mousemove':'mousemove', //Occurs when the pointing device is moved while it is over an element.
                        'focus':'focus',//Occurs when an element receives focus.
                        'focusin':'focusin',//Occurs when an element is about to receive focus
                        'focusout':'focusout',//Occurs when an element is about to lose focus.
                        'blur':'blur',//Occurs when an element loses focus.
                        'keydown':'keydown',//Occurs when a key is pressed down
                        'keyup':'keyup',
                        //https://www.w3.org/TR/touch-events/#list-of-touchevent-types
                        'touchstart':'touchstart', //mobile/tablet only
                        'touchend':'touchend', //mobile/tablet only
                        // 'touchmove':'touchmove',
                        // 'touchcancel':'touchcancel',
                    }
                    for(var val in actionOptions) {
                        $('<option />', {value: val, text: actionOptions[val]}).appendTo(actionField);
                    }
                    actionField.val(clickableShape.action || "click");
                    // Column 3 : Add a input field (type string) to the new row, that represents the msg.payload content 
                    var payloadField = $('<input/>',{class:"node-input-clickable-payload",type:"text",placeholder:"Payload"}).css({"width":"38%","margin-left":"5px","margin-right":"5px"}).appendTo(row);
                    
                    //Column 3 hidden item (payloadType)
                    var payloadTypeField = $('<input/>',{class:"node-input-clickable-payloadType",type:"hidden"}).appendTo(row);
                    var payloadType = supportedPayloadTypes.includes(clickableShape.payloadType) ? clickableShape.payloadType : defaultPayloadType;
                    payloadField.typedInput({
                        default: defaultPayloadType,
                        typeField: payloadTypeField,
                        types: supportedPayloadTypes
                    });
                    payloadField.typedInput("type", payloadType);              
                    payloadField.typedInput("value", clickableShape.payload);   
                    // Column 4 : Add an input field (type string) to the new row, that represents the msg.topic content
                    var topicField = $('<input/>',{class:"node-input-clickable-topic",type:"text",placeholder:"Topic"}).css({"width":"17%","margin-left":"5px","margin-right":"5px"}).appendTo(row);
                    topicField.val(clickableShape.topic);
                    
                    
                    // When there is not yet a topic or payload, the target Id should be cloned (when complete) to the topic and payload (as a default value).
                    targetIdField.on("change", function(){
                        
                        if (payloadType === "str" && !payloadField.typedInput("value")) {
                            payloadField.typedInput('value',$(this).val());
                        }
                        
                        if (!topicField.val() || topicField.val() === "") {
                            topicField.val($(this).val());
                        }
                    });
                    if(node.initialised){
                        let svgStr = node.editor ? node.editor.getValue() : ""; 
                        try {
                            updateSvgIdHelpers(svgStr);    
                        } catch (error) {
                            console.error(error)
                        }
                    }
                },
                removable: true
            });
            
            // Show all the clickable shapes (stored in this node) into the editableList
            if (this.clickableShapes) {
                this.clickableShapes.forEach(function (clickableShape, index) {
                    clickableShapesList.editableList('addItem', {targetId:clickableShape.targetId, action:clickableShape.action, payload:clickableShape.payload, payloadType:clickableShape.payloadType, topic:clickableShape.topic});
                });
            }
            node.initialised = true;
        },
        oneditsave: function() {
            var node = this;
            var annot = this.editor.getSession().getAnnotations();
            this.noerr = 0;
            $("#node-input-noerr").val(0);
            for (var k=0; k < annot.length; k++) {
                if (annot[k].type === "error") {
                    $("#node-input-noerr").val(annot.length);
                    this.noerr = annot.length;
                }
            }
            
            var svgString = this.editor.getValue();
            $("#node-input-svgString").val(svgString);
            this.editor.destroy();
            delete this.editor;
            
            // Copy all the animations from the editableList to this node
            node.smilAnimations = [];
            var smilAnimationsList = $("#node-input-animations-container").editableList('items');
            smilAnimationsList.each(function(i) {
                var amin = getAnimationObjectFromFormRow(this);
                node.smilAnimations.push(amin);
            });
            
            // Copy all the clickable shapes from the editableList to this node
            node.clickableShapes = [];
            var clickableShapesList = $("#node-input-clickable-container").editableList('items');
            clickableShapesList.each(function(i) {
                var clickableShape = $(this);
                var targetId = clickableShape.find(".node-input-clickable-targetId").val();
                var action = clickableShape.find(".node-input-clickable-action").val();
                var payload  = clickableShape.find(".node-input-clickable-payload").val();
                var payloadType  = clickableShape.find(".node-input-clickable-payloadType").val();
                var topic    = clickableShape.find(".node-input-clickable-topic").val();
                
                node.clickableShapes.push({targetId:targetId, action:action, payload:payload, payloadType:payloadType, topic:topic});
            });
        },
        oneditcancel: function() {
            this.editor.destroy();
            delete this.editor;
        },
        oneditresize: function(size) {
            updateEditorHeight(this,this.editor);
        }
    });
</script>

<script type="text/html"  data-template-name="ui_svg_graphics">
    <div class="form-row" id="template-row-group">
        <label for="node-input-group"><i class="fa fa-table"></i> Group</span></label>
        <input type="text" id="node-input-group">
    </div>    
    <div class="form-row" id="template-row-size">
        <label><i class="fa fa-object-group"></i> Size</span></label>
        <input type="hidden" id="node-input-width">
        <input type="hidden" id="node-input-height">
        <button class="editor-button" id="node-input-size"></button>
    </div>
    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    <div class="form-row">
        <!-- Tabsheets -->
        <ul style="background: #fff; min-width: 600px; margin-bottom: 20px;" id="node-svg-tabs"></ul>
    </div>
    <div id="node-svg-tabs-content" style="min-height: 150px">
        <!-- Content of all tabsheets -->
        <div id="node-svg-tab-editor" class="node-svg-tab-content">
            <!-- Ace SVG editor -->
            <div class="form-row" style="margin-bottom:0px;">
                <input type="hidden" id="node-input-svgString" style="width: 100%; height: 100%; ">
            </div>
            <div class="form-row node-text-editor-row form-row-auto-height">
                <div id="node-input-svg-editor" class="node-text-editor" style="width: 100%; height: 100%; min-height:150px;"></div>
                <button id="node-expand-svg-editor" class="editor-button editor-button-small" style="margin-top: 4px;"><i class="fa fa-expand"></i></button>
            </div>
        </div>
        <div id="node-svg-tab-animations" class="node-svg-tab-content">
            <div class="form-row form-row-auto-height">
                <!-- Table with SMIL animations -->
                <ol id="node-input-animations-container"></ol>
            </div>
        </div>
        <div id="node-svg-tab-clickable" class="node-svg-tab-content">
            <div class="form-row" style="padding-left: 2px;">
                <label for="node-input-outputField"><i class="fa fa-envelope"></i> Output to</label>
                <div class="red-ui-typedInput-container" style="width: 70%; margin-right: 5px; margin-left: 3px;">    
                    <button class="red-ui-typedInput-type-select"> 
                        <span class="red-ui-typedInput-type-label">msg.</span>
                    </button>
                    <div class="red-ui-typedInput-input-wrap" style="left: 46px; right: 2px;">
                        <input type="text" id="node-input-outputField" placeholder="Payload" style="width: 100%; margin-right: 0px; margin-left: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px;" autocomplete="disable" dir="" class="red-ui-typedInput-input">
                    </div>
                </div>
            </div>
            <div class="form-row form-row-auto-height">
                <!-- Table with clickable shapes -->
                <ol id="node-input-clickable-container"></ol>
            </div>
        </div>
        <div id="node-svg-tab-settings" class="node-svg-tab-content">
            <div class="form-row">
                <input type="checkbox" id="node-input-showCoordinates" style="display: inline-block; width: auto; vertical-align: top;">
                <label for="node-input-showCoordinates" style="width:50%;"> Show mouse coordinates (as tooltip)</label>
            </div>
            <!--<div class="form-row">-->
            <!--    <input type="checkbox" id="node-input-showMouseLines" style="display: inline-block; width: auto; vertical-align: top;">-->
            <!--    <label for="node-input-showMouseLines" style="width:50%;"> Show vertical/horizontal mouse tracking lines</label>-->
            <!--</div>-->
        </div>
    </div>
</script>
<script type="text/html" data-help-name="ui_svg_graphics">
    <p>A Node Red node to show a vector graphics (SVG) drawing inside the dashboard.</p>
    <p>See our readme page on <a target="_blank" href="https://github.com/bartbutenaers/node-red-contrib-ui-svg">Github</a> for more information.</p>
    <h3>General Properties...</h3>
    <dl class="message-properties">
        <h4>Group</h4>
        <div style="padding-left: 15px">
            Where you want the SVG to be displayed on your dashboard.
        </div>
        <h4>Size</h4>
        <div style="padding-left: 15px">
            The size of the widget on the dashboard
        </div>    
        <h4>Name</h4>
        <div style="padding-left: 15px">
            The name of this node 
        </div>
        <h3><b>Tabs...</b></h3>
        <h4>SVG editor</h4>
        <div style="padding-left: 15px">
            The raw SVG to be displayed.
        </div>
        <h4>Animations</h4>
        <div style="padding-left: 15px">
            A customisable list of animations. Each animation targets an element where you can specify an attribute to animate. 
            <p>Notes...</p>
            <ul>
                <li>The <code>from</code> and <code>to</code> values specify what changes. </li>
                <li><code>Freeze</code> = Keep the state of the last animation frame </li>
                <li><code>Trigger</code> 
                    <ul>
                        <li>Input Message: Dont start the animation, instead, wait for a <code>msg</code> (See Triggering an animation command below) </li>
                        <li>Time Delay: Start animation after a specified time</li>
                        <li>Custom: Use standard <code>begin</code> options e.g. <code>2s; myRect.click; myAnim.end-400ms</code> <i target="blank" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/begin">See here</i>.  </li>
                    </ul>
                </li>
            </ul>
        </div>        
        <h4>Events</h4>
        <div style="padding-left: 15px">
            A customisable list of events. Each event targets an element where you can specify what action (e.g. click, mouseover, focus, etc) and a payload/topic to send upon the specified action.
            Additionally, <code>Output to</code> permits you to specify what part of the <code>msg</code> to send the payload to.
        </div>

    </dl>
    <h3>Output</h3>
    <dl class="message-properties">
        <dt><i>payload (see 'Output to')</i> <span class="property-type">number|string|boolean|object|buffer</span></dt>
        <dd>msg.[Output to] will contain whatever is configured in 'payload'</dd>
        <dd>e.g. if 'Output to' is set to <b>data.value</b> then <code>msg.data.value</code> will contain the value of the <i>payload</i></dd>
        <dd>Additional properties are also added to the msg object. Check the debug output (use show complete msg)</dd>
    </dl>

    <h3>Inputs - Commands <i>(Advanced Usage)</i></h3>
    <dl class="message-properties">
        <dt><i>payload</i> <span class="property-type">string|object|Array</span></dt>
        <dd>It is possible to dynamically trigger animations, update and set element attributes, update text elements via a <code>msg</code>
        <dd>
            <p><b>Triggering an animation command - payload object</b><br>Example...<br>
                <pre style="white-space: pre">[
 {
    "command": "trigger_animation",
    "selector": "#myAnimation",
    "action": "start"
 }
]</pre>
                
                <p><i>Details...</i><br>
                    <ul>
                        <li>command: (string|required) The operation to perform</li>
                        <li>selector: (string|required) A query selector to select the animations</li>
                        <li>action: (string|required) This must be <code>start</code>or <code>stop</code></li>
                    </ul>
                </p>
            </p>


            <p><b>Setting an attribute value command - payload object</b><br>Example...<br>
                <pre style="white-space: pre">[
 {
    "command": "update_attribute",
    "selector": "#myRect > .statusBar",
    "attributeName": "fill",
    "attributevalue": "red"
 },
 {
    "command": "update_attribute",
    "selector": "#myRect > .faultMessage",
    "attributeName": "display",
    "attributevalue": "inline"
 }
]</pre>
                
                <p><i>Details...</i><br>
                    <ul>
                        <li>command: (string|required) The operation to perform</li>
                        <li>selector: (string|required) A query selector to select the animations</li>
                        <li>attributeName: (string|required) This attribute be updated</li>
                        <li>attributevalue: (string|number|required) The value to set the attribute specified by <code>attributeName</code></li>
                    </ul>
                </p>
            </p>


            <p><b>Setting text content command</b><br>Example...<br>
                <P>Topic Method</P>
                <pre style="white-space: pre">
 //send a msg with topic formatted as...   
 //  update_text|selector  
 //... and the payload with the text to display
 var msg = {
    "topic": "update_text|#myRect > .faultMessage",
    "payload": "hello"
 }
 return msg;</pre>

                <P>Command Method - payload object</P>
                <pre style="white-space: pre">[
 {
    "command": "update_text",
    "selector": "#myRect > .faultMessage",
    "textConent": "Hello from a command message"
 }
]</pre>
                
                <p><i>Topic Method Details...</i><br>
                    <ul>
                        <li>topic: (string|required) The format must adhere to "update_topic|selector"</li>
                        <li>payload: (string|required) The text to set</li>
                    </ul>
                </p>
                
                <p><i>Command Method Details...</i><br>
                    <ul>
                        <li>selector: (string|required) A query selector to select the animations</li>
                        <li>textConent: (string|required) This attribute be updated</li>
                    </ul>
                </p>
            </p>

                            
        </dd>

        <dd>GENERAL NOTES...<br>
        <ul>
            <li>Multiple commands objects can be executed if the payload is an array of objects</li>
            <li>Multiple elements can be addressed by the selector (e.g. ".status" would operate on all elements with class "status")</li>
        </ul>
        </dd>
    </dl>
</script>
